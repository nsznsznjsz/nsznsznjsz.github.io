import{d as a}from"./app.cad05c30.js";const e={},n=a('<h1 id="线性表" tabindex="-1"><a class="header-anchor" href="#线性表" aria-hidden="true">#</a> 线性表</h1><p><strong>定义</strong>: 在数据元素的非空有限集合中, 除第一个元素无直接前驱, 最后一个元素无直接后继节点外, 每个元素都有唯一的直接前驱和直接后继节点.</p><h2 id="adt" tabindex="-1"><a class="header-anchor" href="#adt" aria-hidden="true">#</a> ADT</h2><div class="language-C ext-C line-numbers-mode"><pre class="language-C"><code>initList(L)\ngetLength(L)\nget(L, i)\ninsert(L, i , e)\ndel(L, i, e)\nlocate(L, e)\ndestroy(L)\nclear(L)\nisEmpty(L)\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="顺序储存-数组" tabindex="-1"><a class="header-anchor" href="#顺序储存-数组" aria-hidden="true">#</a> 顺序储存(数组)</h2><ul><li>可索引</li><li>插入, 删除慢</li><li>长度受限</li></ul><h2 id="链式储存" tabindex="-1"><a class="header-anchor" href="#链式储存" aria-hidden="true">#</a> 链式储存</h2><ul><li>插入, 删除快</li><li>无法索引</li><li>查询慢</li></ul><h3 id="循环链表" tabindex="-1"><a class="header-anchor" href="#循环链表" aria-hidden="true">#</a> 循环链表</h3><ul><li>将最后一个指针指向表头节点</li><li>从每个节点都可以访问整个列表</li><li>查找前驱节点复杂度为 O(n)</li></ul><h3 id="双向链表" tabindex="-1"><a class="header-anchor" href="#双向链表" aria-hidden="true">#</a> 双向链表</h3><ul><li>每个节点都保存指向前驱节点和后继节点的指针</li><li>查找前驱节点复杂度为 O(1)</li></ul><h3 id="静态链表" tabindex="-1"><a class="header-anchor" href="#静态链表" aria-hidden="true">#</a> 静态链表</h3><ul><li>适用于没有指针/引用的语言</li><li>用大数组模拟内存分配, 记录下一个节点的 index</li></ul><h2 id="查找" tabindex="-1"><a class="header-anchor" href="#查找" aria-hidden="true">#</a> 查找</h2><ol><li>顺序查找法</li></ol><p><code>Data data[SIZE + 1]</code> data[0] 为监视哨, 存放查找元素关键字</p><ol start="2"><li><p>二分法</p><ul><li>顺序结构存储</li><li>按大小有序排列</li></ul></li><li><p>分块查找法</p><ul><li>块内无序</li><li>块与块之间有序</li></ul></li></ol><h1 id="queue" tabindex="-1"><a class="header-anchor" href="#queue" aria-hidden="true">#</a> Queue</h1><p>限定性线性表, FIFO</p><div class="language-C ext-C line-numbers-mode"><pre class="language-C"><code>init(Q)\nisEmpty(Q)\nisFull(Q)\nclear(Q)\ngetHead(Q)\ngetLength(Q)\npush(Q)\nshift(Q)\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="应用" tabindex="-1"><a class="header-anchor" href="#应用" aria-hidden="true">#</a> 应用</h2><p>打印杨辉三角</p><p><strong>优先队列是二叉堆实现</strong></p><h2 id="实现" tabindex="-1"><a class="header-anchor" href="#实现" aria-hidden="true">#</a> 实现</h2><p>队头指针: front</p><p>队尾指针: rear</p><h3 id="链队列" tabindex="-1"><a class="header-anchor" href="#链队列" aria-hidden="true">#</a> 链队列</h3><p>特殊情况: front === rear</p><h3 id="循环队列-数组实现" tabindex="-1"><a class="header-anchor" href="#循环队列-数组实现" aria-hidden="true">#</a> 循环队列 (数组实现)</h3><p>当 rear &lt; front 时, 说明出现循环</p><p>push 时, 当 rear + 1 === MAX_SIZE 时, 令 rear = 0</p><h1 id="stack" tabindex="-1"><a class="header-anchor" href="#stack" aria-hidden="true">#</a> Stack</h1><p>栈是一种限定性线性表, 遵循 LIFO</p><div class="language-C ext-C line-numbers-mode"><pre class="language-C"><code>init(S)\nclear(S)\nisEmpty(S)\nisFull(S)\npush(S, x)\npop(S)\ngetTop(S)\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="应用-1" tabindex="-1"><a class="header-anchor" href="#应用-1" aria-hidden="true">#</a> 应用</h2><ul><li>Hanoi</li><li>递归调用栈 (优化: TCO, 蹦床函数)</li><li>表达式求值</li></ul><h2 id="实现-1" tabindex="-1"><a class="header-anchor" href="#实现-1" aria-hidden="true">#</a> 实现</h2><h3 id="顺序栈" tabindex="-1"><a class="header-anchor" href="#顺序栈" aria-hidden="true">#</a> 顺序栈</h3><div class="language-C ext-C line-numbers-mode"><pre class="language-C"><code>#define Stack_Size 50\ntypedef struct {\n  Element data[Stack_Size];\n  int top;\n} Stack;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="链栈" tabindex="-1"><a class="header-anchor" href="#链栈" aria-hidden="true">#</a> 链栈</h3><div class="language-C ext-C line-numbers-mode"><pre class="language-C"><code>#define Stack_Size 50\ntypedef struct {\n  Element data;\n  StackNode * next;\n} StackNode;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div>',42);e.render=function(a,e){return n};export default e;
