import{r as l,o as n,c as a,a as e,F as r,b as t}from"./app.cad05c30.js";const u={},i=e("h1",{id:"tcp",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#tcp","aria-hidden":"true"},"#"),t(" TCP")],-1),s=e("p",null,"Transmission Control Protocol，传输控制协议。TCP 属于传输层通信协议，基于TCP的应用层协议有: HTTP(s)，SMTP，FTP，Telnet 和 POP3等。",-1),d=e("p",null,[e("strong",null,"优点"),t(": 提供可靠传输，具有拥塞控制")],-1),h=e("p",null,[e("strong",null,"缺点"),t(": 传输效率低，慢启动")],-1),o=e("h2",{id:"特点",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#特点","aria-hidden":"true"},"#"),t(" 特点")],-1),p=e("p",null,[e("strong",null,"面向连接"),t("：使用 TCP 传输数据前，需先建立连接，传输完成后需释放连接。")],-1),c=e("p",null,[e("strong",null,"全双工通信"),t("：建立 TCP 连接后，双方都可以发送数据")],-1),T=e("p",null,[e("strong",null,"可靠通信"),t("：TCP协议保证数据不丢失，无差错，不重复且按序到达")],-1),g=e("p",null,[e("strong",null,"面向字节流"),t("：数据以流的形式传输")],-1),f=e("blockquote",null,[e("p",null,"TCP 会将数据报文分为数据段(data segment)传输，但由于其可靠性，上层可将其视为字节流传输")],-1),C=e("h2",{id:"报文格式",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#报文格式","aria-hidden":"true"},"#"),t(" 报文格式")],-1),S=e("p",null,[e("img",{src:"/assets/tcp-header.a4c15f57.jpg",alt:"TCP Header - 20 byte"})],-1),b=e("p",null,"报文首部最小长度为20字节",-1),N=e("p",null,[e("strong",null,"源端口，目的端口"),t("： 表明发送端所使用的端口号和要连接的目标主机的端口号，不包含IP地址。")],-1),P=e("p",null,[e("strong",null,"序号（seq）"),t("： 表明发送的数据包的顺序，一般为上次发送包中的顺序号+1。 若该数据包是整个TCP连接中的第一个包（SYN包），则该值是随机生成的。")],-1),I=e("p",null,[e("strong",null,"确认号（ack）"),t("： 表明本端TCP已经接收到的数据，其值表示期待对端发送的下一个字节的序号。 实际上告诉对方，在这个序号减1以前的字节已正确接收。 若该数据包是整个TCP连接中的第一个包（SYN包），则确认号一般为0。")],-1),x=e("p",null,[e("strong",null,"数据偏移"),t("： 表示以32位（4字节）为单位的TCP分组头的总长度（首部长度），用于确定用户数据区的起始位置。 在没有可变内容的情况下，TCP头部的大小为20字节，对应该值为5。")],-1),A=e("p",null,[e("strong",null,"标志位"),t("：")],-1),F=e("ul",null,[e("li",null,"紧急标志位（URG）：开启时表明此数据包处于紧急状态应该优先处理"),e("li",null,"确认标志位（ACK）：开启时表明确认号有效，否则忽略确认号"),e("li",null,"推送标志位（PSH）：开启时表明应该尽快交付给应用进程，而不必等到缓存区填满才推送，比如 telnet 的场景"),e("li",null,"复位标志位（RST）：开启时表明TCP连接出现连接出现错误，数据包非法拒绝连接"),e("li",null,"同步标志位（SYN）：开启时表明连接建立的标志"),e("li",null,"终止标志位（FIN）：开启时表明释放一个连接")],-1),m=e("p",null,[e("strong",null,"窗口大小"),t("： 表明期望接受到的数据包字节数，用于拥塞控制。")],-1),q=e("p",null,[e("strong",null,"校验和"),t("： 实现对TCP报文头以及数据区进行校验。")],-1),R=e("p",null,[e("strong",null,"紧急指针"),t("： 在紧急状态下（URG打开），指出窗口中紧急数据的位置（末端）。")],-1),Y=e("p",null,[e("strong",null,"选项（可变）"),t("： 用于支持一些特殊的变量，比如最大分组长度(MSS)，然后将其填充为32 bit的整数倍。")],-1),_=e("h2",{id:"有限状态机及状态变迁",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#有限状态机及状态变迁","aria-hidden":"true"},"#"),t(" 有限状态机及状态变迁")],-1),k=e("p",null,[e("img",{src:"/assets/tcp-state-machine.5342a5bc.jpg",alt:"TCP State Machine"})],-1),E=e("p",null,[e("img",{src:"/assets/tcp-state-transition.60caf875.jpg",alt:"TCP State Transition"})],-1),M=e("h2",{id:"三次握手",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#三次握手","aria-hidden":"true"},"#"),t(" 三次握手")],-1),B=e("p",null,[e("img",{src:"/assets/tcp-shake-hands.93e76afa.jpg",alt:"TCP Shake hands"})],-1),W=e("p",null,[e("strong",null,"第一次握手"),t("： 客户端向服务器发送请求连接报文，SYN=1，seq=x(随机值)，客户端进入 SYN_SEND 状态，同时打开定时器")],-1),y=e("p",null,[e("strong",null,"第二次握手"),t("： 服务器向客户端回信，SYN=1，ACK=1，seq=y(随机值)，ack=x+1，服务器端进入 SYN-RCVD 状态")],-1),w=e("p",null,[e("strong",null,"第三次握手"),t("： 客户端向服务器回信，SYN=0，ACK=1，seq=x+1，ack=y+1，此次握手可以携带数据")],-1),K=e("h3",{id:"为什么需要第三次握手",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#为什么需要第三次握手","aria-hidden":"true"},"#"),t(" 为什么需要第三次握手?")],-1),L=e("p",null,"这主要是为了防止已失效的连接请求报文段突然又传送到了B(服务器端)，因而产生错误。所谓“已失效的连接请求报文段”是这样产生的：",-1),O=e("p",null,[e("strong",null,"正常情况")],-1),j=e("p",null,"A发出连接请求，但因连接请求报文丢失而未收到确认，于是A再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。A共发送了两个连接请求报文段，其中第一个丢失，第二个到达了B，没有“已丢失的连接请求报文段”。",-1),D=e("p",null,[e("strong",null,"异常情况")],-1),H=e("p",null,"A发出的第一个连接请求报文段并没有丢失，而是在某些网络节点长时间滞留了，以致延误到连接释放以后的某个时间才能到达B。",-1),Q=e("p",null,"本来这是一个早已失效的报文段。但B收到此失效的连接请求报文段后，就误认为A又发出了一次新的连接请求。于是又向A发出确认报文段，同意建立连接。",-1),v=e("p",null,"假定不采用三次握手，那么只要B发出确认，新的连接就建立了。由于现在A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数据。但B却以为新的连接已经建立了，并一直等待A发来数据，B的许多资源就这样浪费了。",-1),G=e("p",null,"采用三次握手的方法可以防止上述异常现象的发生。",-1),U=e("blockquote",null,[e("p",null,[e("strong",null,"如果在规定时间内未收到回信")]),e("p",null,"会重新发送SYN报文段。如果在几次重发后仍然没有得到服务器的SYN+ACK响应就会放弃，端口切换CLOSE状态，并报告上层。")],-1),V=e("h3",{id:"syn-flood-攻击",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#syn-flood-攻击","aria-hidden":"true"},"#"),t(" SYN Flood 攻击")],-1),z=e("p",null,[t("syn flood 是一种经典的 ddos攻击手段，这里面用到了TCP 三次握手存在的漏洞。 在上面的图中，可以看到当服务端接收到 SYN 后进入 SYN-RECV 状态，此时的连接称为"),e("strong",null,"半连接"),t("，同时会被服务端写入一个"),e("strong",null,"半连接队列"),t("。")],-1),J=e("p",null,"如果攻击者在短时间内不断的向服务端发送大量的 SYN 包而不响应，那么服务器的 半连接队列很快会被写满，从而导致无法工作。实现 syn flood 的手段，可以通过伪造源 IP 的方式，这样服务器的响应就永远到达不了客户端 (握手无法完成)，或通过设定客户端防火墙规则达到同样的目的。",-1),X=e("p",null,"对 syn flood 实现拦截是比较困难的，可以通过启用 syn_cookies 的方式实现缓解，但最好的办法是通过专业的防火墙来解决。",-1),Z=e("h2",{id:"四次挥手",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#四次挥手","aria-hidden":"true"},"#"),t(" 四次挥手")],-1),$=e("p",null,[e("img",{src:"/assets/tcp-wave.9f3a609f.jpg",alt:"TCP wave"})],-1),ll=e("h3",{id:"为什么需要四次挥手",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#为什么需要四次挥手","aria-hidden":"true"},"#"),t(" 为什么需要四次挥手?")],-1),nl=e("p",null,"当一方发送了FIN，则表示在这一方不再会有数据的发送，进入半关闭状态，但是仍需要接受对方发送的消息。",-1),al=e("p",null,"其中当被动关闭方受到对方的FIN时，此时往往可能还有数据需要发送过去，因此无法立即发送FIN(也就是无法将FIN与ACK合并发送)，",-1),el=e("p",null,"而是在等待自己的数据发送完毕后再单独发送FIN，因此整个过程需要四次交互。",-1),rl=e("h3",{id:"fin-wait-2-状态一直未接受到-fin-怎么办",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#fin-wait-2-状态一直未接受到-fin-怎么办","aria-hidden":"true"},"#"),t(" FIN_WAIT_2 状态一直未接受到 FIN 怎么办?")],-1),tl=e("p",null,[t("1。为实现全双工，TCP协议规定需要一直等待FIN才会进入"),e("code",null,"TIME_WAIT"),t("，即使网线被剪短... 2。从Telnet，FTP，到Apache，Nginx，几乎所有的TCP服务的实现均遵循了收到客户端的FIN之后立即发送FIN这么一个不成文的事实，也就是说，对于主动关闭的一方，当它发送完FIN进入"),e("code",null,"FIN_WAIT_2"),t("状态后，可以在预期的时间内收到对端的FIN从而进入TIMEWAIT状态 3。Linux 2.2 以上可以根据"),e("code",null,"tcp_fin_timeout"),t("配置定时器时长，默认 60s，超时后并不会进入TIMEWAIT状态，也不会发送reset。而 Windows 下表现一致，但是会发送reset")],-1),ul=e("h3",{id:"为什么存在-time-wait-状态",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#为什么存在-time-wait-状态","aria-hidden":"true"},"#"),t(" 为什么存在 TIME_WAIT 状态?")],-1),il=e("p",null,"当客户端收到了对方的FIN时，会进入TIME_WAIT状态，需要等待 2MSL 以直到确认不会再有重传的数据包之后再进入CLOSED状态",-1),sl=e("p",null,"这么做的原因主要是为了可靠的关闭连接。为了防止网络不稳定情况，比如: 发送给对方的ACK可能会无法及时收到，此时对方可能重传FIN过来，如果提前进入CLOSE则会返回RST而不是ACK，就会影响关闭流程。",-1),dl=e("p",null,[t("如果频繁的主动关闭连接，可能会产生大量"),e("code",null,"TIME_WAIT"),t("，由于"),e("code",null,"TIME_WAIT"),t("的连接占用了一个句柄及少量内存(4K)，那么就有可能会影响其他连接的建立，")],-1),hl=e("blockquote",null,[e("p",null,[t("MSL叫Max Segment Lifetime，也就是关于一个数据包在网络中传输的最大生命周期的预设。关于其时长，RFC 中有 "),e("code",null,"Arbitrarily defined to be 2 minutes.")])],-1),ol=e("h2",{id:"可靠传输",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#可靠传输","aria-hidden":"true"},"#"),t(" 可靠传输")],-1),pl=e("p",null,"1。无差错 2。发送&接受效率匹配",-1),cl=e("h3",{id:"自动重传请求协议-arq",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#自动重传请求协议-arq","aria-hidden":"true"},"#"),t(" 自动重传请求协议 ARQ")],-1),Tl=e("p",null,[e("strong",null,"定义"),t(" 传输出现差错时，接收方自动请求发送方重传出错数据")],-1),gl=e("p",null,[e("strong",null,"作用"),t(" 无差错传输")],-1),fl=e("p",null,[e("strong",null,"确认机制"),t(" 1。发送方每发送一帧，都需要等待接收方应答信号 2。接收方每接受一帧，都需要反馈一个应答信号 3。若接收方不反馈应答信号，则发送方必需一直等待")],-1),Cl=e("p",null,[e("strong",null,"超时重传"),t(" 1。发送方发送帧后开启计时器 2。超时后重发该数据帧，直到发送成功为止")],-1),Sl=e("h4",{id:"停等式-arq-stop-and-wait",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#停等式-arq-stop-and-wait","aria-hidden":"true"},"#"),t(" 停等式 ARQ (Stop and Wait)")],-1),bl=e("p",null,"发送窗口大小 = 1 接受窗口大小 = 1",-1),Nl=e("h4",{id:"后退n帧协议-连续arq协议",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#后退n帧协议-连续arq协议","aria-hidden":"true"},"#"),t(" 后退N帧协议 (连续ARQ协议)")],-1),Pl=e("p",null,"发送窗口大小 > 1 接受窗口大小 = 1",-1),Il=e("h5",{id:"累计确认",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#累计确认","aria-hidden":"true"},"#"),t(" 累计确认")],-1),xl=e("p",null,"收到多个数据分组后，只需对按序到达的最后一个分组确认",-1),Al=e("p",null,[e("strong",null,"优点"),t(" 实现简单")],-1),Fl=e("p",null,[e("strong",null,"缺点"),t(" 无法向发送方反馈所有正确接收到的分组信息")],-1),ml=e("h5",{id:"后退n帧",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#后退n帧","aria-hidden":"true"},"#"),t(" 后退N帧")],-1),ql=e("h2",{id:"拥塞控制",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#拥塞控制","aria-hidden":"true"},"#"),t(" 拥塞控制")],-1),Rl=e("p",null,"慢启动，拥塞避免，快速重传，快速恢复",-1),Yl=e("h2",{id:"q-a",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#q-a","aria-hidden":"true"},"#"),t(" Q&A")],-1),_l=e("h3",{id:"为什么多个tcp可以连接同一端口-比如http的80端口",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#为什么多个tcp可以连接同一端口-比如http的80端口","aria-hidden":"true"},"#"),t(" 为什么多个TCP可以连接同一端口，比如HTTP的80端口?")],-1),kl=e("p",null,"TODO",-1),El=e("h3",{id:"rst-是什么-为什么会出现",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#rst-是什么-为什么会出现","aria-hidden":"true"},"#"),t(" RST 是什么，为什么会出现")],-1),Ml=e("p",null,"RST 是一个特殊的标记，用来表示当前应该立即终止连接。以下这些情况都会产生RST：",-1),Bl=e("ul",null,[e("li",null,"向一个未被监听的端口发送数据"),e("li",null,"对方已经调用 close 关闭连接"),e("li",null,"存在一些数据未处理(接收缓冲区)，请求关闭连接时，会发送RST强制关闭"),e("li",null,"某些请求发生了超时")],-1),Wl=t("RST 机制有时候也会被利用，做一些"),yl={href:"https://nmap.org/man/zh/man-port-scanning-techniques.html",target:"_blank",rel:"noopener noreferrer"},wl=t("端口扫描"),Kl=e("h2",{id:"exercises",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#exercises","aria-hidden":"true"},"#"),t(" Exercises")],-1),Ll=e("p",null,"1。A,B两台机器都正常工作,B机器未监听任何端口。如果A机器向B机器80端口发送SYN包,会收到何种类型的回包?",-1),Ol=e("blockquote",null,[e("p",null,"RST包")],-1),jl=e("p",null,"2。TCP建立连接的过程采用三次握手，已知第三次握手报文的发送序列号为1000，确认序列号为2000，请问第二次握手报文的发送序列号和确认序列号分别为?",-1),Dl=e("blockquote",null,[e("p",null,"1999,1000")],-1);u.render=function(t,u){const Hl=l("OutboundLink");return n(),a(r,null,[i,s,d,h,o,p,c,T,g,f,C,S,b,N,P,I,x,A,F,m,q,R,Y,_,k,E,M,B,W,y,w,K,L,O,j,D,H,Q,v,G,U,V,z,J,X,Z,$,ll,nl,al,el,rl,tl,ul,il,sl,dl,hl,ol,pl,cl,Tl,gl,fl,Cl,Sl,bl,Nl,Pl,Il,xl,Al,Fl,ml,ql,Rl,Yl,_l,kl,El,Ml,Bl,e("p",null,[Wl,e("a",yl,[wl,e(Hl)])]),Kl,Ll,Ol,jl,Dl],64)};export default u;
