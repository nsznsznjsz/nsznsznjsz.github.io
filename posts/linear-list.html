<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <link rel="icon" href="/logo.png"><title>线性表 | Celeste's blog</title><meta name="description" content="Technique && Life"><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="VuePress 2.0.0-beta.21">
    <link rel="modulepreload" href="/assets/app.cad05c30.js"><link rel="modulepreload" href="/assets/linear-list.html.c915dd26.js"><link rel="modulepreload" href="/assets/linear-list.html.0419cfaa.js">
    <link rel="stylesheet" href="/assets/style.b2f4734d.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="layout"><main class="layout__main"><!--[--><article class="page prose max-w-none"><!--[--><h1 id="线性表" tabindex="-1"><a class="header-anchor" href="#线性表" aria-hidden="true">#</a> 线性表</h1><p><strong>定义</strong>: 在数据元素的非空有限集合中, 除第一个元素无直接前驱, 最后一个元素无直接后继节点外, 每个元素都有唯一的直接前驱和直接后继节点.</p><h2 id="adt" tabindex="-1"><a class="header-anchor" href="#adt" aria-hidden="true">#</a> ADT</h2><div class="language-C ext-C line-numbers-mode"><pre class="language-C"><code>initList(L)
getLength(L)
get(L, i)
insert(L, i , e)
del(L, i, e)
locate(L, e)
destroy(L)
clear(L)
isEmpty(L)
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="顺序储存-数组" tabindex="-1"><a class="header-anchor" href="#顺序储存-数组" aria-hidden="true">#</a> 顺序储存(数组)</h2><ul><li>可索引</li><li>插入, 删除慢</li><li>长度受限</li></ul><h2 id="链式储存" tabindex="-1"><a class="header-anchor" href="#链式储存" aria-hidden="true">#</a> 链式储存</h2><ul><li>插入, 删除快</li><li>无法索引</li><li>查询慢</li></ul><h3 id="循环链表" tabindex="-1"><a class="header-anchor" href="#循环链表" aria-hidden="true">#</a> 循环链表</h3><ul><li>将最后一个指针指向表头节点</li><li>从每个节点都可以访问整个列表</li><li>查找前驱节点复杂度为 O(n)</li></ul><h3 id="双向链表" tabindex="-1"><a class="header-anchor" href="#双向链表" aria-hidden="true">#</a> 双向链表</h3><ul><li>每个节点都保存指向前驱节点和后继节点的指针</li><li>查找前驱节点复杂度为 O(1)</li></ul><h3 id="静态链表" tabindex="-1"><a class="header-anchor" href="#静态链表" aria-hidden="true">#</a> 静态链表</h3><ul><li>适用于没有指针/引用的语言</li><li>用大数组模拟内存分配, 记录下一个节点的 index</li></ul><h2 id="查找" tabindex="-1"><a class="header-anchor" href="#查找" aria-hidden="true">#</a> 查找</h2><ol><li>顺序查找法</li></ol><p><code>Data data[SIZE + 1]</code> data[0] 为监视哨, 存放查找元素关键字</p><ol start="2"><li><p>二分法</p><ul><li>顺序结构存储</li><li>按大小有序排列</li></ul></li><li><p>分块查找法</p><ul><li>块内无序</li><li>块与块之间有序</li></ul></li></ol><h1 id="queue" tabindex="-1"><a class="header-anchor" href="#queue" aria-hidden="true">#</a> Queue</h1><p>限定性线性表, FIFO</p><div class="language-C ext-C line-numbers-mode"><pre class="language-C"><code>init(Q)
isEmpty(Q)
isFull(Q)
clear(Q)
getHead(Q)
getLength(Q)
push(Q)
shift(Q)
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="应用" tabindex="-1"><a class="header-anchor" href="#应用" aria-hidden="true">#</a> 应用</h2><p>打印杨辉三角</p><p><strong>优先队列是二叉堆实现</strong></p><h2 id="实现" tabindex="-1"><a class="header-anchor" href="#实现" aria-hidden="true">#</a> 实现</h2><p>队头指针: front</p><p>队尾指针: rear</p><h3 id="链队列" tabindex="-1"><a class="header-anchor" href="#链队列" aria-hidden="true">#</a> 链队列</h3><p>特殊情况: front === rear</p><h3 id="循环队列-数组实现" tabindex="-1"><a class="header-anchor" href="#循环队列-数组实现" aria-hidden="true">#</a> 循环队列 (数组实现)</h3><p>当 rear &lt; front 时, 说明出现循环</p><p>push 时, 当 rear + 1 === MAX_SIZE 时, 令 rear = 0</p><h1 id="stack" tabindex="-1"><a class="header-anchor" href="#stack" aria-hidden="true">#</a> Stack</h1><p>栈是一种限定性线性表, 遵循 LIFO</p><div class="language-C ext-C line-numbers-mode"><pre class="language-C"><code>init(S)
clear(S)
isEmpty(S)
isFull(S)
push(S, x)
pop(S)
getTop(S)
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="应用-1" tabindex="-1"><a class="header-anchor" href="#应用-1" aria-hidden="true">#</a> 应用</h2><ul><li>Hanoi</li><li>递归调用栈 (优化: TCO, 蹦床函数)</li><li>表达式求值</li></ul><h2 id="实现-1" tabindex="-1"><a class="header-anchor" href="#实现-1" aria-hidden="true">#</a> 实现</h2><h3 id="顺序栈" tabindex="-1"><a class="header-anchor" href="#顺序栈" aria-hidden="true">#</a> 顺序栈</h3><div class="language-C ext-C line-numbers-mode"><pre class="language-C"><code>#define Stack_Size 50
typedef struct {
  Element data[Stack_Size];
  int top;
} Stack;
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="链栈" tabindex="-1"><a class="header-anchor" href="#链栈" aria-hidden="true">#</a> 链栈</h3><div class="language-C ext-C line-numbers-mode"><pre class="language-C"><code>#define Stack_Size 50
typedef struct {
  Element data;
  StackNode * next;
} StackNode;
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><!--]--></article><!--]--></main><aside class="layout__sub"><!--[--><div>Sidebar</div><!--]--></aside><aside class="layout__extra"><!--[--><div class="sticky top-12 p-4 mr-8"><h3 class="pb-1 text-lg font-bold select-none">CATALOG</h3><ul><!--[--><li class="catalog__item"><a aria-current="page" href="/posts/linear-list.html#adt" class="router-link-active router-link-exact-active catalog__link">ADT</a><!----></li><li class="catalog__item"><a aria-current="page" href="/posts/linear-list.html#%E9%A1%BA%E5%BA%8F%E5%82%A8%E5%AD%98-%E6%95%B0%E7%BB%84" class="router-link-active router-link-exact-active catalog__link">顺序储存(数组)</a><!----></li><li class="catalog__item"><a aria-current="page" href="/posts/linear-list.html#%E9%93%BE%E5%BC%8F%E5%82%A8%E5%AD%98" class="router-link-active router-link-exact-active catalog__link">链式储存</a><!----></li><li class="catalog__item"><a aria-current="page" href="/posts/linear-list.html#%E6%9F%A5%E6%89%BE" class="router-link-active router-link-exact-active catalog__link">查找</a><!----></li><li class="catalog__item"><a aria-current="page" href="/posts/linear-list.html#%E5%BA%94%E7%94%A8" class="router-link-active router-link-exact-active catalog__link">应用</a><!----></li><li class="catalog__item"><a aria-current="page" href="/posts/linear-list.html#%E5%AE%9E%E7%8E%B0" class="router-link-active router-link-exact-active catalog__link">实现</a><!----></li><li class="catalog__item"><a aria-current="page" href="/posts/linear-list.html#%E5%BA%94%E7%94%A8-1" class="router-link-active router-link-exact-active catalog__link">应用</a><!----></li><li class="catalog__item"><a aria-current="page" href="/posts/linear-list.html#%E5%AE%9E%E7%8E%B0-1" class="router-link-active router-link-exact-active catalog__link">实现</a><!----></li><!--]--></ul></div><!--]--></aside><header class="layout__header"><!--[--><div class="header h-full flex flex-col justify-center items-center relative overflow-hidden"><div class="flex flex-col items-start"><div class="z-30 min-w-max"><!--[--><a href="/tags/data-structure.html" class="header__pill-link" style="--pill-color:#9c27b0;">数据结构</a><!--]--><a class="header__pill-link" href="https://github.com/nsznsznjsz/blog/edit/main/2019/10/24/linear-list.md" target="_blank">编辑此页</a></div><h1 class="my-6 z-30 text-white text-8xl font-medium">线性表</h1></div><div class="flex z-30"><div class="header__meta-item">发表于 2019-10-24</div><div class="header__meta-item">更新于 2021-3-1</div></div><div class="flex z-30"><div class="header__meta-item"> 分类于 <!--[--><span class="header__categories"><!--[--><a href="/categories/computer-science.html" class="header__category">计科</a><a href="/categories/computer-science/data-structure.html" class="header__category">数据结构</a><a href="/categories/computer-science/data-structure/linear-list.html" class="header__category">linear-list</a><!--]--></span><!--]--></div></div></div><!--]--></header><footer class="layout__footer"><!--[--><div class="flex flex-col items-center m-4 py-4 text-gray-400 text-sm select-none"><span>Copyright © 2021 – 2021 Celeste</span><span>Powered by <a href="https://vuepress.vuejs.org/" target="_blank" class="underline">Vuepress</a></span></div><!--]--></footer><nav class="layout__nav overflow-hidden z-50"><!--[--><div class="navbar navbar_transparent" style=""><ul class="flex"><li class="navbar__link"><a href="/" class="font-bold">CELESTE&#39;S BLOG</a></li></ul><ul class="flex"><!--[--><li class="navbar__link"><a href="/archives.html" class="">ARCHIVES</a></li><li class="navbar__link"><a href="/categories.html" class="">CATEGORIES</a></li><li class="navbar__link"><a href="/tags.html" class="">TAGS</a></li><li class="navbar__link"><a href="/about.html" class="">ABOUT</a></li><!--]--></ul></div><!--]--></nav><!----></div><!--]--></div>
    <script type="module" src="/assets/app.cad05c30.js" defer></script>
  </body>
</html>
