<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <link rel="icon" href="/logo.png"><title>平衡二叉树（AVL树） | Celeste's blog</title><meta name="description" content="Technique && Life"><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="VuePress 2.0.0-beta.21">
    <link rel="modulepreload" href="/assets/app.cad05c30.js"><link rel="modulepreload" href="/assets/avl-tree.html.b01882c1.js"><link rel="modulepreload" href="/assets/avl-tree.html.d1b6690a.js">
    <link rel="stylesheet" href="/assets/style.b2f4734d.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="layout"><main class="layout__main"><!--[--><article class="page prose max-w-none"><!--[--><h1 id="平衡二叉树" tabindex="-1"><a class="header-anchor" href="#平衡二叉树" aria-hidden="true">#</a> 平衡二叉树</h1><p>平衡二叉查找树，简称：平衡二叉树，由前苏联的数学家 Adelse-Velskil 和 Landis 在1962 年提出的高度平衡的二叉树，根据科学家的英文名也称为AVL 树。指的是所有节点平衡因子的绝对值不大于1的二叉树叫做平衡二叉树。</p><p>你可以通过 <a href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html" target="_blank" rel="noopener noreferrer">AVL Tree Visualzation<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!----></span></a> 来模拟AVL树的各个操作。</p><blockquote><p>平衡因子：左子树高减去右子树高</p></blockquote><blockquote><p>平衡二叉树并不一定是一个完全二叉树，例如高度为4且非叶子节点平衡因子均为1的AVL树</p><p><img src="/assets/avl-tree.19b8ba6c.png" alt="image-20210115121840387"></p><p>由上图我们还可以发现，高度为4的AVL树最少有7个节点，最多有15个节点</p></blockquote><h2 id="插入" tabindex="-1"><a class="header-anchor" href="#插入" aria-hidden="true">#</a> 插入</h2><p>插入操作与二叉排序树相似，但插入后可能引起[失衡][#失衡]。</p><ol><li>通过排序规则选择合适的插入位置</li><li>创建一新的叶子节点，插入该位置</li><li>向上更新路径上每个节点的平衡因子，当平衡因子的绝对值大于1时引起失衡，先进行平衡操作</li><li>重复步骤3，直到达到根节点</li></ol><h2 id="删除" tabindex="-1"><a class="header-anchor" href="#删除" aria-hidden="true">#</a> 删除</h2><p>插入操作与二叉排序树相似，但插入后可能引起[失衡][#失衡]。</p><ol><li>通过查找规则找到删除节点，找不到则结束，如果为只有一个节点的树的根节点，则删除根节点后结束</li><li>找到删除节点在中序遍历中的前驱节点或后继节点（必为叶子节点）</li><li>交换两节点，删除叶子节点</li><li>向上更新路径上每个节点的平衡因子，当平衡因子的绝对值大于1时引起失衡，先进行平衡操作</li><li>重复步骤4，直到达到根节点</li></ol><h2 id="查找" tabindex="-1"><a class="header-anchor" href="#查找" aria-hidden="true">#</a> 查找</h2><p>查找操作与二叉排序树相同，因为AVL树总是平衡的，所以耗费O(log <em>n</em>)时间。AVL树不会因查找过程而改变。</p><h2 id="失衡" tabindex="-1"><a class="header-anchor" href="#失衡" aria-hidden="true">#</a> 失衡</h2><ul><li><strong>LL</strong>：对失衡节点顺时针旋转</li><li><strong>LR</strong>：对失衡节点左孩子节点逆时针旋转，对失衡节点顺时针旋转</li><li><strong>RR</strong>：对失衡节点逆时针旋转</li><li><strong>RL</strong>：对失衡节点左孩子节点顺时针旋转，对失衡节点逆时针旋转</li></ul><p><img src="/assets/avl-tree-rebalancing.f8eaa785.png" alt="AVL Tree Rebalancing"></p><!--]--></article><!--]--></main><aside class="layout__sub"><!--[--><div>Sidebar</div><!--]--></aside><aside class="layout__extra"><!--[--><div class="sticky top-12 p-4 mr-8"><h3 class="pb-1 text-lg font-bold select-none">CATALOG</h3><ul><!--[--><li class="catalog__item"><a aria-current="page" href="/posts/avl-tree.html#%E6%8F%92%E5%85%A5" class="router-link-active router-link-exact-active catalog__link">插入</a><!----></li><li class="catalog__item"><a aria-current="page" href="/posts/avl-tree.html#%E5%88%A0%E9%99%A4" class="router-link-active router-link-exact-active catalog__link">删除</a><!----></li><li class="catalog__item"><a aria-current="page" href="/posts/avl-tree.html#%E6%9F%A5%E6%89%BE" class="router-link-active router-link-exact-active catalog__link">查找</a><!----></li><li class="catalog__item"><a aria-current="page" href="/posts/avl-tree.html#%E5%A4%B1%E8%A1%A1" class="router-link-active router-link-exact-active catalog__link">失衡</a><!----></li><!--]--></ul></div><!--]--></aside><header class="layout__header"><!--[--><div class="header h-full flex flex-col justify-center items-center relative overflow-hidden"><div class="flex flex-col items-start"><div class="z-30 min-w-max"><!--[--><a href="/tags/data-structure.html" class="header__pill-link" style="--pill-color:#9c27b0;">数据结构</a><!--]--><a class="header__pill-link" href="https://github.com/nsznsznjsz/blog/edit/main/2021/01/02/avl-tree.md" target="_blank">编辑此页</a></div><h1 class="my-6 z-30 text-white text-8xl font-medium">平衡二叉树（AVL树）</h1></div><div class="flex z-30"><div class="header__meta-item">发表于 2021-01-02</div><div class="header__meta-item">更新于 2021-3-1</div></div><div class="flex z-30"><div class="header__meta-item"> 分类于 <!--[--><span class="header__categories"><!--[--><a href="/categories/computer-science.html" class="header__category">计科</a><a href="/categories/computer-science/data-structure.html" class="header__category">数据结构</a><a href="/categories/computer-science/data-structure/tree.html" class="header__category">树</a><!--]--></span><!--]--></div></div></div><!--]--></header><footer class="layout__footer"><!--[--><div class="flex flex-col items-center m-4 py-4 text-gray-400 text-sm select-none"><span>Copyright © 2021 – 2021 Celeste</span><span>Powered by <a href="https://vuepress.vuejs.org/" target="_blank" class="underline">Vuepress</a></span></div><!--]--></footer><nav class="layout__nav overflow-hidden z-50"><!--[--><div class="navbar navbar_transparent" style=""><ul class="flex"><li class="navbar__link"><a href="/" class="font-bold">CELESTE&#39;S BLOG</a></li></ul><ul class="flex"><!--[--><li class="navbar__link"><a href="/archives.html" class="">ARCHIVES</a></li><li class="navbar__link"><a href="/categories.html" class="">CATEGORIES</a></li><li class="navbar__link"><a href="/tags.html" class="">TAGS</a></li><li class="navbar__link"><a href="/about.html" class="">ABOUT</a></li><!--]--></ul></div><!--]--></nav><!----></div><!--]--></div>
    <script type="module" src="/assets/app.cad05c30.js" defer></script>
  </body>
</html>
