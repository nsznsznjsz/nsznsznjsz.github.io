<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <link rel="icon" href="/logo.png"><title>Vue Conf 21 | Celeste's blog</title><meta name="description" content="Technique && Life"><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="VuePress 2.0.0-beta.21">
    <link rel="modulepreload" href="/assets/app.cad05c30.js"><link rel="modulepreload" href="/assets/vue-conf-21.html.6806193f.js"><link rel="modulepreload" href="/assets/vue-conf-21.html.36c32b97.js">
    <link rel="stylesheet" href="/assets/style.b2f4734d.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="layout"><main class="layout__main"><!--[--><article class="page prose max-w-none"><!--[--><h1 id="vue-conf-21" tabindex="-1"><a class="header-anchor" href="#vue-conf-21" aria-hidden="true">#</a> Vue Conf 21</h1><h2 id="vite" tabindex="-1"><a class="header-anchor" href="#vite" aria-hidden="true">#</a> Vite</h2><h3 id="为什么更快" tabindex="-1"><a class="header-anchor" href="#为什么更快" aria-hidden="true">#</a> 为什么更快？</h3><p>Vite 快速的核心原因时改变了原有的 Bundler-Based Dev Server，而采用 ESM-Based Dev Server 方案。Bundle-Base 的方案中，<strong>Full Bundler</strong> 决定了开发服务器的每次启动都十分低效，需要从入口文件解析整个依赖树并将其打包。而全新的 ESM-Based 开发服务器只需要做每个文件的 <strong>Transform</strong>，文件依赖解析则交由 ESM 完成，如此一来，开发服务器真的就只需要监听一个端口那么简单！</p><blockquote><p>其实可能还有依赖预编译，当然这也是为了更快</p></blockquote><h3 id="ssr-目标" tabindex="-1"><a class="header-anchor" href="#ssr-目标" aria-hidden="true">#</a> SSR 目标</h3><ul><li>Dev Bundless</li><li>Node 环境下加载 ESM <ul><li>兼容 Node 低版本</li><li>兼容生态环境</li></ul></li><li>支持 HMR+Plugin</li></ul><h2 id="编译优化思路" tabindex="-1"><a class="header-anchor" href="#编译优化思路" aria-hidden="true">#</a> 编译优化思路</h2><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>return {
  c() {
    /* create  */
  },
  m() {
    /* mount   */
  },
  p() {
    /* patch   */
  },
  d() {
    /* destory */
  },
}

// @vue/reactive
return {
  c() {
    /* create  */
  },
  m() {
    /* mount   */
  },
  d() {
    /* destory */
  },
}
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><h2 id="element3" tabindex="-1"><a class="header-anchor" href="#element3" aria-hidden="true">#</a> Element3</h2><ul><li>Headless/Styled</li><li>webGL -&gt; 材质</li></ul><h2 id="新一代构建工具" tabindex="-1"><a class="header-anchor" href="#新一代构建工具" aria-hidden="true">#</a> 新一代构建工具</h2><blockquote><p>别让构建流程成为技术包袱</p></blockquote><p><img src="/assets/the-next-builder.09ec4490.png" alt="The Next Builder"></p><h3 id="type-first" tabindex="-1"><a class="header-anchor" href="#type-first" aria-hidden="true">#</a> Type First</h3><p>Type First, 类型优先 -&gt; Typescript</p><ul><li>类型提示</li><li>智能补全</li><li>省下写文档的时间</li><li>方便重构</li></ul><h3 id="将类型检查放到编译外" tabindex="-1"><a class="header-anchor" href="#将类型检查放到编译外" aria-hidden="true">#</a> 将类型检查放到编译外</h3><ul><li>esbuild: 单纯的 Typescript 词法扩展并不会让编译变慢</li><li>把 tsc 作为 lint 的一部分</li></ul><h3 id="be-explicit" tabindex="-1"><a class="header-anchor" href="#be-explicit" aria-hidden="true">#</a> Be Explicit</h3><ul><li><p>用 define* 的帮助函数：类型补全</p></li><li><p>不要省略文件名：类型</p></li></ul><h3 id="module-by-default" tabindex="-1"><a class="header-anchor" href="#module-by-default" aria-hidden="true">#</a> Module By Default</h3><ul><li><p>拥抱 ES Module</p></li><li><p>重新看待 Externals，在 ESM 时代，简单的 Externals 并不好用</p><ul><li>alias</li><li>import maps</li></ul></li><li><p><code>__filename</code> / <code>__dirname</code> / <code>require.resolve</code> =&gt; <code>i<wbr>mport.meta.url</code></p></li><li><p><code>p<wbr>rocess.env</code> =&gt; <code>i<wbr>mport.meta.env</code></p><ul><li>来自 Node.js，环境并不存在</li><li>浏览器端的 <code>p<wbr>rocess.env</code> 并不是环境，而是配置</li><li><code>NODE_ENV</code>有各种约定俗称的用法</li></ul></li><li><p>JSON modules =&gt; 标准只有 default import</p></li></ul><h3 id="构建工具的兼容难题" tabindex="-1"><a class="header-anchor" href="#构建工具的兼容难题" aria-hidden="true">#</a> 构建工具的兼容难题</h3><p>浏览器兼容 &amp; 技术债务</p><ul><li>IE 11 =&gt; Retail</li><li>Dynamic Import</li><li>Node.js Polyfills &amp; Shims</li></ul><h2 id="减少-node-依赖" tabindex="-1"><a class="header-anchor" href="#减少-node-依赖" aria-hidden="true">#</a> 减少 Node 依赖</h2><p>抹平差距</p><ul><li>Define：简单的字符串替换</li><li>Mock / Sham：无实际功能的模拟，如 fs</li><li>Shim / Polyfill：模拟完整功能，如 path</li></ul><p>用 globalThis 代替 global/window</p><h2 id="jsx" tabindex="-1"><a class="header-anchor" href="#jsx" aria-hidden="true">#</a> JSX</h2><p><img src="/assets/from-template-to-render-function.7c53f8b1.png" alt="From Template to Render Function"></p><p>利用 Babel 赋予的编译能力，实现模板与 JSX 跨语言联动，以用户的需求为抓手，摸索出一套适用于 Vue 的 JSX 方法论，打造 Vue 生态闭环，利用 TypeScript 的类型提示，为更习惯于 JSX 的开发者赋能。</p><h3 id="什么是-真正的-jsx" tabindex="-1"><a class="header-anchor" href="#什么是-真正的-jsx" aria-hidden="true">#</a> 什么是“真正的”JSX</h3><p>JSX 最早由 Facebook 起草，用于 React，但不是 tc39 的规范，因此浏览器不会直接实现。JSX 需要由编译器和框架来&quot;赋能&quot;，以下列代码为例：</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code>&lt;h1&gt;Hello, world!&lt;/h1&gt;
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>经过编译后（通过 Babel, ts 等工具转换 AST）：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>import { createVNode as _createVNode } from &quot;vue&quot;
_createVNode(&quot;h1&quot;, null, &quot;Hello, world!&quot;)
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点</h3><ol><li><p><strong>额外的运行时</strong>：JSX 无法判断 slot 或 children，只能在运行时判断</p></li><li><p><strong>信息不足</strong>：JSX 语法自由的代价就是难以实现静态分析，编译信息较少，Vue3 引入的<code>PatchFlags</code>无法完全做到，导致 JSX 编译后的 <code>Render Function</code> 性能差一些</p></li></ol><h2 id="composition-api" tabindex="-1"><a class="header-anchor" href="#composition-api" aria-hidden="true">#</a> Composition API</h2><blockquote><p>PPT: <a href="https://talks.antfu.me/2021/vueconf-china" target="_blank" rel="noopener noreferrer">https://talks.antfu.me/2021/vueconf-china<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!----></span></a></p></blockquote><h3 id="为什么要组合式" tabindex="-1"><a class="header-anchor" href="#为什么要组合式" aria-hidden="true">#</a> 为什么要组合式？</h3><ul><li><p>对象式变量来源不明确</p></li><li><p>Type 补全复杂</p></li></ul><h3 id="什么是组合式" tabindex="-1"><a class="header-anchor" href="#什么是组合式" aria-hidden="true">#</a> 什么是组合式？</h3><ul><li><p>可复用逻辑的组合，其中每个函数都可以独立使用</p></li><li><p>专注点分离</p></li></ul><p><img src="/assets/composable-dependency-graph.dda80e69.png" alt="Composable Dependency Graph"></p><h3 id="reactive" tabindex="-1"><a class="header-anchor" href="#reactive" aria-hidden="true">#</a> Reactive</h3><p>不同于 React，Vue 的 <code>Setup()</code> 只会在组件建立时执行一次，在此期间会建立起数据与逻辑之间的连结。</p><ul><li>建立输入 → 输出的连结</li><li>输出会根据输入的改变而改变（就像你的 Excel 一样 🎉）</li></ul><p><img src="/assets/reactive-like-excel.809cd4da.png" alt="Reactive Like Excel"></p><h3 id="best-practices" tabindex="-1"><a class="header-anchor" href="#best-practices" aria-hidden="true">#</a> Best practices</h3><ul><li><p>优先使用 <code>ref</code> 而不是 <code>reactive</code></p><ul><li><p>显示调用，类型检查</p></li><li><p>相比 Reactive 局限更少：<code>reactive </code>有类型，无法解构……</p></li></ul></li><li><p>Ref 自动解包</p><ul><li><p><code>watch</code> 直接接收 Ref ，回调中会自动解包</p></li><li><p>Ref 在模板中自动解包</p></li><li><p>使用 <code>reactive</code> 解包嵌套 <code>ref</code>，用来代替 <code>toRef</code></p></li></ul></li><li><p><code>unref</code> API</p><ul><li><p><code>unref(a) =&gt; isRef(a) ? a.value : a</code></p></li><li><p>接收 Ref 作为函数参数 <code>(a, b) =&gt; unref(a) + unref(b)</code></p></li></ul></li><li><p><code>type MaybeRef&lt;T&gt; = Ref&lt;T&gt; | T </code></p></li><li><p>重复使用 ref，<code>ref </code>会自动解包的！</p><ul><li><code>newRef = isRef(foo) ? foo : ref(foo)</code>和<code>newRef = ref(foo)</code> 一样的</li></ul></li><li><p>副作用自动清除</p><ul><li><p>组件内的 <code>watch</code> 和 <code>computed</code> 会在销毁时自动清除</p></li><li><p>Vue 3.2: <code>effectScope</code></p></li></ul></li><li><p>类型安全的 <code>Provide</code>/<code>Inject</code>：<code>InjectionKey&lt;T&gt;</code></p></li><li><p>状态共享</p><ul><li><p>直接用 Composition API 把状态抽离</p></li><li><p>使用 <code>provide</code>/<code>inject</code> 来共享应用层面的状态</p></li></ul></li><li><p>小技巧：<code>useVModel</code></p></li></ul><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>export function useVModel(props, name) {
  const emit = getCurrentInstance.emit
  return computed({
    get() {
      return props[name]
    },
    set(v) {
      emit(`update${name}`, v)
    },
  })
}
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><ul><li>Vue Demi: 一套代码，同时适用 Vue 2 和 Vue 3</li></ul><h2 id="vue-的-flutter-实践" tabindex="-1"><a class="header-anchor" href="#vue-的-flutter-实践" aria-hidden="true">#</a> Vue 的 Flutter 实践</h2><ul><li>移动端技术栈演变：WebView -&gt; Hybrid -&gt; RN -&gt; Flutter</li></ul><p><img src="/assets/kraken-intro.d248cc26.png" alt="Kraken Intro"></p><p><img src="/assets/kraken-diff-tech.a58e0615.png" alt="Kraken Diff Tech"></p><!--]--></article><!--]--></main><aside class="layout__sub"><!--[--><div>Sidebar</div><!--]--></aside><aside class="layout__extra"><!--[--><div class="sticky top-12 p-4 mr-8"><h3 class="pb-1 text-lg font-bold select-none">CATALOG</h3><ul><!--[--><li class="catalog__item"><a aria-current="page" href="/posts/vue-conf-21.html#vite" class="router-link-active router-link-exact-active catalog__link">Vite</a><!----></li><li class="catalog__item"><a aria-current="page" href="/posts/vue-conf-21.html#%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF" class="router-link-active router-link-exact-active catalog__link">编译优化思路</a><!----></li><li class="catalog__item"><a aria-current="page" href="/posts/vue-conf-21.html#element3" class="router-link-active router-link-exact-active catalog__link">Element3</a><!----></li><li class="catalog__item"><a aria-current="page" href="/posts/vue-conf-21.html#%E6%96%B0%E4%B8%80%E4%BB%A3%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7" class="router-link-active router-link-exact-active catalog__link">新一代构建工具</a><!----></li><li class="catalog__item"><a aria-current="page" href="/posts/vue-conf-21.html#%E5%87%8F%E5%B0%91-node-%E4%BE%9D%E8%B5%96" class="router-link-active router-link-exact-active catalog__link">减少 Node 依赖</a><!----></li><li class="catalog__item"><a aria-current="page" href="/posts/vue-conf-21.html#jsx" class="router-link-active router-link-exact-active catalog__link">JSX</a><!----></li><li class="catalog__item"><a aria-current="page" href="/posts/vue-conf-21.html#composition-api" class="router-link-active router-link-exact-active catalog__link">Composition API</a><!----></li><li class="catalog__item"><a aria-current="page" href="/posts/vue-conf-21.html#vue-%E7%9A%84-flutter-%E5%AE%9E%E8%B7%B5" class="router-link-active router-link-exact-active catalog__link">Vue 的 Flutter 实践</a><!----></li><!--]--></ul></div><!--]--></aside><header class="layout__header"><!--[--><div class="header h-full flex flex-col justify-center items-center relative overflow-hidden"><div class="flex flex-col items-start"><div class="z-30 min-w-max"><!--[--><a href="/tags/vue.html" class="header__pill-link" style="--pill-color:#ff9800;">vue</a><a href="/tags/vueconf.html" class="header__pill-link" style="--pill-color: #cddc39;">vueconf</a><a href="/tags/frontend.html" class="header__pill-link" style="--pill-color:#ff5722;">frontend</a><!--]--><a class="header__pill-link" href="https://github.com/nsznsznjsz/blog/edit/main/2021/05/22/vue-conf-21.md" target="_blank">编辑此页</a></div><h1 class="my-6 z-30 text-white text-8xl font-medium">Vue Conf 21</h1></div><div class="flex z-30"><div class="header__meta-item">发表于 2021-05-22</div><div class="header__meta-item">更新于 2021-7-5</div></div><div class="flex z-30"><div class="header__meta-item"> 分类于 <!--[--><span class="header__categories"><!--[--><a href="/categories/computer-science.html" class="header__category">计科</a><a href="/categories/computer-science/frontend.html" class="header__category">frontend</a><a href="/categories/computer-science/frontend/vue.html" class="header__category">vue</a><!--]--></span><!--]--></div></div></div><!--]--></header><footer class="layout__footer"><!--[--><div class="flex flex-col items-center m-4 py-4 text-gray-400 text-sm select-none"><span>Copyright © 2021 – 2021 Celeste</span><span>Powered by <a href="https://vuepress.vuejs.org/" target="_blank" class="underline">Vuepress</a></span></div><!--]--></footer><nav class="layout__nav overflow-hidden z-50"><!--[--><div class="navbar navbar_transparent" style=""><ul class="flex"><li class="navbar__link"><a href="/" class="font-bold">CELESTE&#39;S BLOG</a></li></ul><ul class="flex"><!--[--><li class="navbar__link"><a href="/archives.html" class="">ARCHIVES</a></li><li class="navbar__link"><a href="/categories.html" class="">CATEGORIES</a></li><li class="navbar__link"><a href="/tags.html" class="">TAGS</a></li><li class="navbar__link"><a href="/about.html" class="">ABOUT</a></li><!--]--></ul></div><!--]--></nav><!----></div><!--]--></div>
    <script type="module" src="/assets/app.cad05c30.js" defer></script>
  </body>
</html>
